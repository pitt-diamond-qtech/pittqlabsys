# AWG520 Templates and Examples

This directory contains reusable templates and examples for Tektronix AWG520 arbitrary waveform generator operations.

## Directory Structure

```
awg520_templates/
├── waveforms/          # Template waveform files (.wfm) - NOT tracked in git
├── *.seq               # Template sequence files (.seq) - ARE tracked in git
├── generate_templates.py # Script to generate template waveforms
└── README.md          # This file
```

## Important Notes

### **scan.seq Files**
- **Purpose**: These are the main sequence files that get transferred to the AWG520 via FTP
- **Content**: Tables that reference waveform files and define execution order
- **Usage**: Only ONE sequence file can be active on the AWG520 at a time
- **Templates**: The `.seq` files here serve as starting points for your experiments

### **Waveform Files (.wfm)**
- **Purpose**: Binary files containing actual signal data
- **Status**: NOT tracked in git (too large, binary)
- **Generation**: Use `generate_templates.py` to create small template waveforms
- **Usage**: Referenced by sequence files

## Available Template Sequences

### 1. **odmr_scan.seq** - ODMR Experiment Sequence
- **Purpose**: Microwave generation and laser control for ODMR experiments
- **Channels**: Uses both CH1 and CH2 for microwave and control signals
- **Markers**: M1 for timing, M2 for laser control
- **Waveforms**: References sine waves for microwave, ramps for scanning

### 2. **confocal_scan.seq** - Confocal Microscopy Sequence
- **Purpose**: Galvanometer scanning and laser control for confocal imaging
- **Channels**: CH1 for X-scan, CH2 for Y-scan and sync
- **Markers**: M1 for scan control, M2 for laser and acquisition timing
- **Waveforms**: References ramps for scanning, square waves for timing

## Usage Workflow

### 1. **Generate Template Waveforms**
```bash
cd examples/awg520_templates
python generate_templates.py
```
This creates small template `.wfm` files in the `waveforms/` directory.

### 2. **Use Sequence Files Directly or Copy for Customization**
The `.seq` files here are actual AWG520 sequence files that can be used directly:

```python
from src.Controller.awg520 import AWG520Device

# Use template sequence directly
device = AWG520Device(settings={
    'seq_file': 'examples/awg520_templates/odmr_scan.seq',  # Direct use
    'ip_address': '172.17.39.2',
    'scpi_port': 4000,
    'ftp_port': 21,
    'ftp_user': 'usr',
    'ftp_pass': 'pw'
})
```

**OR** copy and modify for your experiment:

```python
import shutil
import os

# Copy template sequence to your experiment directory
template_path = 'examples/awg520_templates/odmr_scan.seq'
experiment_path = 'my_experiment/scan.seq'

# Ensure target directory exists
os.makedirs(os.path.dirname(experiment_path), exist_ok=True)
shutil.copy(template_path, experiment_path)

# Modify the sequence file as needed for your specific experiment
# Note: These are binary-like files, so edit carefully or regenerate using AWGFile
```

### 3. **Modify for Your Specific Needs**
- **Duration**: Adjust the duration values in the sequence file
- **Waveforms**: Change waveform file references
- **Markers**: Modify marker states (0=OFF, 1=ON)
- **Channels**: Adjust channel assignments
- **Regenerate**: For complex changes, use `AWGFile` to create new sequence files

### 4. **Load in AWG520 Device**
```python
# The device will automatically load this sequence file via FTP
device.setup()
```

## Best Practices

### 1. **Template Management**
- Keep template sequence files small and focused
- Use descriptive names that indicate purpose
- Document any special requirements or dependencies
- Update templates when you discover better patterns

### 2. **File Organization**
- Store experiment-specific files in your experiment directory
- Use templates as starting points, not final files
- Keep repository clean by ignoring large generated files
- Only ONE sequence file can be active on AWG520 at a time

### 3. **Version Control**
- Template sequence files (`.seq`) ARE tracked (small, text)
- Waveform files (`.wfm`) are NOT tracked (large, binary)
- Experiment-specific files are ignored
- Keep templates updated with improvements

## File Formats

### Sequence Files (.seq)
- **Format**: AWG520-specific binary-like format with text header
- **Header**: `MAGIC 3002` and `LINES N` (where N is the number of data lines)
- **Data Lines**: `"waveform1.wfm","waveform2.wfm",duration,channel,marker1,marker2`
- **Footer**: `JUMP_MODE SOFTWARE`
- **Generated by**: `AWGFile` class in `src/Model/awg_file.py`

### Sequence File Structure:
```
MAGIC 3002
LINES N
"waveform1.wfm","waveform2.wfm",duration,channel,marker1,marker2
"waveform3.wfm","waveform4.wfm",duration,channel,marker1,marker2
...
JUMP_MODE SOFTWARE
```

### Data Line Format:
- **Column 1**: Waveform file for Channel 1 (quoted)
- **Column 2**: Waveform file for Channel 2 (quoted) 
- **Column 3**: Duration in samples or time units
- **Column 4**: Channel number (1 or 2)
- **Column 5**: Marker 1 state (0=OFF, 1=ON)
- **Column 6**: Marker 2 state (0=OFF, 1=ON)

### Example:
```
"sine_10MHz.wfm","sine_10MHz.wfm",1000,1,0,0
```
This line:
- Uses `sine_10MHz.wfm` for both channels
- Duration: 1000 samples
- Channel: 1
- Marker 1: OFF (0)
- Marker 2: OFF (0)

### Waveform Files (.wfm)
- **Format**: Binary format specific to AWG520
- **Content**: Amplitude and timing data
- **Generation**: Use `AWGFile` class or `generate_templates.py`
- **Size**: Keep templates small (< 1KB) for repository

## Troubleshooting

### Common Issues:
- **Sequence not loading**: Check file format and MAGIC header
- **Waveform not found**: Ensure referenced `.wfm` files exist in the same directory
- **Timing problems**: Verify duration values and clock settings
- **Marker issues**: Ensure marker values are 0 or 1 (not ON/OFF)
- **File corruption**: Check that `LINES N` count matches actual data lines

### Validation:
- Verify `MAGIC 3002` header is present
- Check that `LINES N` count matches your data lines
- Ensure all waveform references exist
- Confirm file ends with `JUMP_MODE SOFTWARE`
- Test loading on AWG520 device

### Getting Help:
- Check the main AWG520 documentation in `docs/`
- Review example implementations in `examples/awg520_example.py`
- Use the device's `is_connected` property to verify communication
- Check sequence file format matches AWG520 requirements
- Use `AWGFile` module for generating proper sequence files

## Creating Custom Sequence Files

### Using the AWGFile Module
For complex experiments, you can create custom sequence files using the `AWGFile` class:

```python
from src.Model.awg_file import AWGFile
import numpy as np

# Create AWG file writer
awg = AWGFile(ftype="SEQ", timeres_ns=1, out_dir=".")

# Define your sequence
waveforms = [
    ("sine_10MHz.wfm", "sine_10MHz.wfm", 1000, 1, 0, 0),
    ("ramp_100kHz.wfm", "ramp_100kHz.wfm", 2000, 2, 1, 0),
    ("gaussian_pulse.wfm", "gaussian_pulse.wfm", 500, 1, 0, 1)
]

# Write sequence file
awg.write_sequence(waveforms, "my_custom_sequence")
```

### Manual Editing
You can also manually edit the sequence files, but be careful:
- Keep the `MAGIC 3002` header
- Update the `LINES N` count to match your data lines
- Maintain the exact format: `"waveform1","waveform2",duration,channel,m1,m2`
- End with `JUMP_MODE SOFTWARE`

### Best Practices
1. **Start with templates**: Use the provided `.seq` files as starting points
2. **Test incrementally**: Make small changes and test
3. **Backup files**: Always backup working sequence files
4. **Use AWGFile**: For complex sequences, use the proper API
5. **Validate format**: Ensure the file structure is correct

## Memory Optimization and Advanced Waveform Generation

The AWG520 has memory constraints that require smart waveform generation strategies. The enhanced `AWGFile` class now includes algorithms to handle both sequence types efficiently.

### **Memory Constraints**
- **Total Memory**: 4M words (as per AWG520 specification)
- **Per Sample**: 5 bytes (4 bytes float + 1 byte marker)
- **Max Samples**: ~800K samples per waveform
- **At 1ns resolution**: ~800μs total time per channel
- **⚠️  This is much more limiting than initially assumed!**

### **Critical Limitations**
The 4M word memory constraint severely limits experiment duration:

- **At 1 GHz clock**: Only ~800μs total duration
- **At 100 MHz clock**: Only ~8ms total duration  
- **At 10 MHz clock**: Only ~80ms total duration

**This makes memory optimization absolutely critical for practical experiments!**

### **Two Sequence Categories**

#### **Type A: Few Intense Pulses with Long Dead Time**
- **Use Case**: ODMR experiments, laser control, timing experiments
- **Strategy**: Single waveform with sparse pulses
- **Memory Efficiency**: Excellent for long total duration
- **Example**: 4 pulses over 2 seconds = very memory efficient

#### **Type B: Many Pulses with Shorter Dead Time**
- **Use Case**: Scanning, repetitive measurements, high-frequency pulsing
- **Strategy**: Automatic chunking when memory limit exceeded
- **Memory Efficiency**: Good, automatically splits into multiple files
- **Example**: 500 pulses with 1μs spacing = may need chunking

### **Memory Optimization Methods**

#### **1. `create_pulse_sequence_waveform()`**
```python
from src.Model.awg_file import AWGFile

awg = AWGFile(ftype="WFM", timeres_ns=1, out_dir=".")

# Create few pulses with long dead time
pulse_times = [0.001, 0.100, 0.500, 1.000]  # seconds
pulse_durations = [0.000001, 0.000001, 0.000001, 0.000001]  # 1μs each
pulse_amplitudes = [1.0, 1.0, 1.0, 1.0]

waveform_file = awg.create_pulse_sequence_waveform(
    pulse_times, pulse_durations, pulse_amplitudes,
    total_duration=2.0, sample_rate=1e9, name="odmr_experiment"
)
```

#### **2. `create_many_pulses_waveform()`**
```python
# Create many pulses with automatic chunking
waveform_file = awg.create_many_pulses_waveform(
    num_pulses=500,
    pulse_duration=0.000001,  # 1μs
    pulse_amplitude=1.0,
    dead_time=0.000001,       # 1μs
    sample_rate=1e9,          # 1GHz
    name="scanning_experiment",
    optimize_memory=True       # Enable automatic chunking
)
```

#### **3. `create_optimized_sequence()` - Auto-Detection**
```python
# Define pulse specifications
pulse_specs = [
    {'time': 0.001, 'duration': 0.000001, 'amplitude': 1.0, 'shape': 'gaussian'},
    {'time': 0.100, 'duration': 0.000001, 'amplitude': 1.0, 'shape': 'gaussian'},
    # ... more pulses
]

# Auto-detect best strategy
seq_file, waveform_files = awg.create_optimized_sequence(
    pulse_specs, total_duration=2.0, sample_rate=1e9, 
    name="auto_optimized", optimize_strategy="auto"
)
```

### **Automatic Strategy Selection**

The system automatically chooses the best approach:

- **Few pulses (≤10) + Long dead time (>1ms)**: Use `pulse_sequence` strategy
- **Many pulses (>100)**: Use `chunked` strategy with automatic splitting
- **Medium pulses**: Use `single` strategy for balanced approach

### **Chunking Strategy for Long Sequences**

When memory limits are exceeded:

1. **Split into chunks**: Automatically divide into optimal chunk sizes
2. **Create sequence file**: References all chunked waveform files
3. **Maintain timing**: Preserves exact timing relationships
4. **File management**: Organizes chunks with descriptive names

### **Pulse Shapes Supported**

- **Square**: Sharp, rectangular pulses
- **Gaussian**: Smooth, bell-shaped pulses
- **Sine**: Oscillatory pulses with smooth envelope

### **Example Usage**

See `memory_optimization_examples.py` for comprehensive examples:

```bash
cd examples/awg520_templates
python memory_optimization_examples.py
```

This script demonstrates:
- Type A: Few intense pulses with long dead time
- Type B: Many pulses with shorter dead time
- Memory constraint analysis
- Custom pulse pattern creation
- Automatic optimization strategies

### **Best Practices for Memory Optimization**

1. **Choose appropriate strategy**: Let auto-detection work, or specify manually
2. **Consider sample rate**: Lower sample rates allow longer durations
3. **Optimize pulse density**: Sparse pulses are more memory-efficient
4. **Use chunking**: For very long sequences, chunking is automatic
5. **Monitor memory usage**: Check the memory analysis output

### **Performance Considerations**

- **Generation time**: Complex patterns may take longer to generate
- **File size**: Chunked approaches create multiple files
- **Transfer time**: Multiple files may take longer to upload to AWG520
- **Memory efficiency**: Significant improvement over naive approaches
